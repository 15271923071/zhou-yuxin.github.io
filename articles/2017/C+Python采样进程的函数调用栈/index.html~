<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>C+Python采样进程的函数调用栈</title>
        <link rel="stylesheet" type="text/css" media="all" href="../../../style.css">
    </head>
    <body class="post-template-default single single-post postid-14 single-format-standard logged-in admin-bar single-author singular two-column left-sidebar customize-support">
        <div id="page" class="hfeed">
            <div id="main">
                <div id="primary">
                    <div id="content" role="main">        
                        <article id="post-14" class="post-14 post type-post status-publish format-standard hentry category-18">
                            <header class="entry-header">
                                <h1 class="entry-title">C+Python采样进程的函数调用栈</h1>
                            </header>
                            <div class="entry-content">

<p>其实这篇博客中所用到的技术也是基于perf的，只是再加入了一些扩展——如何dump进程地址空间中的函数。</p>

<p>===================阶段一：C实现采样工具================</p>

<p>第一步肯定是要通过perf采样，获得进程的callchain。在《<a href="../Linux perf子系统的使用（二）——采样/index.html">Linux perf子系统的使用（二）——采样</a>》一文中已经说明了，目前试验可行的采样方案是需要使用到signal的（SIGIO）。而很多系统调用，比如read()、sleep()等等，原本阻塞的行为会被信号打断。本来我是打算把perf的采样功能封装成一个.so文件，由Python来调用。但是呢，由于阻塞操作会被信号打断，所以Python里面的代码也会不按照预期的行为执行，弄得一团糟。因此，为了隔离信号的作用域，我决定把perf的采样功能单独编译成一个可执行文件，然后作为Python的子进程，Python通过管道读取采样结果。</p>

      ﻿                      </div>
                        </article>
                    </div>
                </div>
            </div>
            <footer id="colophon" role="contentinfo">
                <div id="site-generator">周坚石@南京大学软件学院 504849766@qq.com</div>
            </footer>
        </div>
    </body>
</html>
